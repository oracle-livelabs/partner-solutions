# Integration Tests to Validate Kubernetes YAML

## Introduction

In the previous sections we used some autogenerated files together with YAML fragments defined in `src/main/kubernetes` for deploying to Kubernetes. As involuntary mistakes can occur in manually created YAML files, it would be great to test those before applying them in any namespace.

Estimated Time: 20 minutes

### Objectives

In this section, you will:
* Learn about `PodDisruptionBudget` resource type.
* Test the YAML of a `PodDisruptionBudget`.

### Prerequisites

This section assumes you have:
* An Oracle Cloud account with access to a Kubernetes cluster.
* All previous sections successfully completed.
* Access to a container registry that is reachable from your Kubernetes cluster.

To make testing against a mock Kubernetes API extremely simple, Quarkus provides the `WithKubernetesTestServer` annotation which automatically launches a mock of the Kubernetes API server and sets the proper environment variables needed. 
To take advantage of these features, the `quarkus-test-kubernetes-client` dependency needs to be added in *pom.xml*:

```
    <copy>
    <dependency>
        <groupId>io.quarkus</groupId>
        <artifactId>quarkus-test-kubernetes-client</artifactId>
        <scope>test</scope>
    </dependency>
    </copy>
```

## Task 1: Create Integration Tests to Validate Kubernetes YAML Resources

A `PodDisruptionBudget` is a Kubernetes resource that you can define to protect your critical workloads against voluntary disruptions such as:

* deleting the deployment that manages the pod

* manually delete a pod that is not managed by a Deployment resource.

You can create a `PodDisruptionBudget` for workloads encapsulated in other Kubernetes resources like `Deployment`, `ReplicaSet`, `StatefulSet`.

In the folder [src/main/kubernetes](https://github.com/ammbra/joker/blob/main/src/main/kubernetes) you have a `pdb.yml` file:

```yaml
    <copy>
    apiVersion: policy/v1
    kind: PodDisruptionBudget
    metadata:
    spec:
      minAvailable: 1
      selector:
        matchLabels:
          app.kubernetes.io/name: joker
     </copy>
```

Typically, you will install [src/main/kubernetes/pdb.yml]([src/main/kubernetes](https://github.com/ammbra/joker/blob/master/src/main/kubernetes/pdb.yml)) in an Kubernetes environment and will observe that the configuration is rejected because the name of the resource is missing. 
However, you can avoid such a scenario by creating an integration test for the `PodDisruptionBudget` resource defined in the file.

1. Create a Java class named `PodDisruptionBudgetTest` under `src/test/java/org/acme/example` :

```
<copy>
public class PodDisruptionBudgetTest {
            
}
</copy>
```

2. As this is a Quarkus test, you should annotate it with `@QuarkusTest`. To signal the mocked Kubernetes context, annotate the class with `@WithKubernetesTestServer`.

```
<copy>
import io.quarkus.test.junit.DisabledOnIntegrationTest;
import io.quarkus.test.junit.QuarkusTest;
import io.quarkus.test.kubernetes.client.WithKubernetesTestServer;


@WithKubernetesTestServer
@QuarkusTest
@DisabledOnIntegrationTest(forArtifactTypes = DisabledOnIntegrationTest.ArtifactType.NATIVE_BINARY)
public class PodDisruptionBudgetTest {
    
}
</copy>
```

Use `@DisabledOnIntegrationTest` annotation to exclude this test when running the native executable.

3. Add the mock Kubernetes server context via a field:

```
<copy>
import io.fabric8.kubernetes.client.server.mock.KubernetesServer;

import io.quarkus.test.junit.DisabledOnIntegrationTest;
import io.quarkus.test.junit.QuarkusTest;
import io.quarkus.test.kubernetes.client.WithKubernetesTestServer;
import io.quarkus.test.kubernetes.client.KubernetesTestServer;


@WithKubernetesTestServer
@QuarkusTest
@DisabledOnIntegrationTest(forArtifactTypes = DisabledOnIntegrationTest.ArtifactType.NATIVE_BINARY)
public class PodDisruptionBudgetTest {
    
    @KubernetesTestServer
    KubernetesServer mocKubernetesServer;
    
}
</copy>
```
4. Construct the test method by adding the path to the YAML file as variable:

```
<copy>
import io.fabric8.kubernetes.client.server.mock.KubernetesServer;

import io.quarkus.test.junit.DisabledOnIntegrationTest;
import io.quarkus.test.junit.QuarkusTest;
import io.quarkus.test.kubernetes.client.WithKubernetesTestServer;
import io.quarkus.test.kubernetes.client.KubernetesTestServer;


import java.io.FileNotFoundException;
import java.net.URISyntaxException;

@WithKubernetesTestServer
@QuarkusTest
@DisabledOnIntegrationTest(forArtifactTypes = DisabledOnIntegrationTest.ArtifactType.NATIVE_BINARY)
public class PodDisruptionBudgetTest {
    
    @KubernetesTestServer
    KubernetesServer mocKubernetesServer;

    @Test
    public void testPdbFromFile() throws URISyntaxException, FileNotFoundException {
        String path = "./src/main/kubernetes/pdb.yml";
    }
}
</copy>
```

5. Create the `PodDisruptionBudget` Java resource that gets populated based on the content of the YAML.

```
<copy>
package org.acme.example;


import io.fabric8.kubernetes.api.model.policy.v1.PodDisruptionBudget;
import io.fabric8.kubernetes.client.server.mock.KubernetesServer;
import io.quarkus.test.junit.DisabledOnIntegrationTest;
import io.quarkus.test.junit.QuarkusTest;
import io.quarkus.test.kubernetes.client.KubernetesTestServer;
import io.quarkus.test.kubernetes.client.WithKubernetesTestServer;
import org.junit.jupiter.api.Test;

import java.io.FileNotFoundException;
import java.net.URISyntaxException;

import static org.junit.jupiter.api.Assertions.assertThrows;


@WithKubernetesTestServer
@QuarkusTest
@DisabledOnIntegrationTest(forArtifactTypes = DisabledOnIntegrationTest.ArtifactType.NATIVE_BINARY)
public class PodDisruptionBudgetTest {

    @KubernetesTestServer
    KubernetesServer mocKubernetesServer;

    @Test
    public void testPdbFromFile() throws URISyntaxException, FileNotFoundException {
        String path = "./src/main/kubernetes/pdb.yml";
        PodDisruptionBudget pdb = mocKubernetesServer.getClient().policy().v1().podDisruptionBudget().load(path).get();
    }

}
</copy>
```

6. As the YAML content is invalid, you should expect an exception to be thrown:

```
<copy>
package org.acme.example;


import io.fabric8.kubernetes.api.model.policy.v1.PodDisruptionBudget;
import io.fabric8.kubernetes.client.KubernetesClientException;
import io.fabric8.kubernetes.client.server.mock.KubernetesServer;
import io.quarkus.test.junit.DisabledOnIntegrationTest;
import io.quarkus.test.junit.QuarkusTest;
import io.quarkus.test.kubernetes.client.KubernetesTestServer;
import io.quarkus.test.kubernetes.client.WithKubernetesTestServer;
import org.junit.jupiter.api.Test;

import java.io.FileNotFoundException;
import java.net.URISyntaxException;

import static org.junit.jupiter.api.Assertions.assertThrows;


@WithKubernetesTestServer
@QuarkusTest
@DisabledOnIntegrationTest(forArtifactTypes = DisabledOnIntegrationTest.ArtifactType.NATIVE_BINARY)
public class PodDisruptionBudgetTest {

    @KubernetesTestServer
    private KubernetesServer mockKubernetes;


    @Test
    public void testPdbFromFile() throws URISyntaxException, FileNotFoundException {
        String path = "./src/main/kubernetes/pdb.yml";
        PodDisruptionBudget pdb = mockKubernetes.getClient().policy().v1().podDisruptionBudget().load(path).get();
        assertThrows(KubernetesClientException.class, () ->   mockKubernetes.getClient().policy().v1().podDisruptionBudget().create(pdb)) ;
    }

}
</copy>
```

7. By running the test (via ContinuousTesting/IDE/application package) you can get exceptions but also what is wrong with the resource.

8. You can also test YAML as a text block:

```
<copy>
package org.acme.example;


import io.fabric8.kubernetes.api.model.policy.v1.PodDisruptionBudget;
import io.fabric8.kubernetes.client.KubernetesClientException;
import io.fabric8.kubernetes.client.server.mock.KubernetesServer;
import io.quarkus.test.junit.DisabledOnIntegrationTest;
import io.quarkus.test.junit.QuarkusTest;
import io.quarkus.test.kubernetes.client.KubernetesTestServer;
import io.quarkus.test.kubernetes.client.WithKubernetesTestServer;
import org.junit.jupiter.api.Test;

import java.io.FileNotFoundException;
import java.net.URISyntaxException;

import static org.junit.jupiter.api.Assertions.assertThrows;


@WithKubernetesTestServer
@QuarkusTest
@DisabledOnIntegrationTest(forArtifactTypes = DisabledOnIntegrationTest.ArtifactType.NATIVE_BINARY)
public class PodDisruptionBudgetTest {

    @KubernetesTestServer
    private KubernetesServer mockKubernetes;

    private String flavoredInput = """
            apiVersion: policy/v1
            kind: PodDisruptionBudget
            metadata:
            spec:
              minAvailable: 1
              selector:
                matchLabels:
                  app.kubernetes.io/name: joker
            """;

    @Test
    public void testCustomYAMLInput() throws URISyntaxException, FileNotFoundException {
        assertThrows(KubernetesClientException.class, () ->   mockKubernetes.getClient().policy().v1().podDisruptionBudget().
        load(flavoredInput).dryRun()) ;
    }

}
</copy>
```

## Learn More

* [Efficient Resource Management with Kubernetes](https:dn.dev/kube-dev-practices)
* [Best Practices for Kube-Native Java Apps Workshop](https://redhat-scholars.github.io/kube-native-java-apps)

## Acknowledgements
* **Authors** - Ana-Maria Mihalceanu, Sr. Developer Advocate, Oracle | Elder Moraes, Developer Advocate, Red Hat
* **Last Updated By/Date** - Ana-Maria Mihalceanu,  September 2022